---
layout: post
title:  "JVM自动内存管理机制"
date:   2014-06-22 00:00:00 
categories: jvm
---
为什么要理解其中内存管理机制？
每当提到java和相关微软.net平台下的C#，都能静静乐道说道gc这门技术，在这个平台相比C/C++不再为资源释放而苦恼，java是通过虚拟机来实现每个对象的管理以及内存的管理，其中复杂的内存处理机制更大限度解决资源释放问题。所以试想一旦程序出现内存泄漏或者溢出问题，同时又不了解虚拟机内存的管理机制，那么排除这些错误会是一件非常困难的事。

1.Java内存区域
java程序是是被java虚拟机运行的，当然虚拟机在运行java程序是会对应管理一大块内存的。然而这块内存区域通常被虚拟机划分为若干个不同的数据区域。这些数据区域有的是随着虚拟机进程启动而存在，有的则是以来用户线程的启动关闭而创建和销毁的。通常java虚拟机所管理的内存会有以下几个运行时数据区域：

![Alt text](http://7u2srn.com1.z0.glb.clouddn.com/@/images/post/jvm03_01.png)

1. 程序计数器：
可看作当前线程所执行的字节码的行号指示器。然而字节码解释器就是依靠改变这个计数器值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都依靠这个计数器完成。如果线程正在执行一个java方法，那么程序计数器指定的就是虚拟机字节码地址。

2. java虚拟机栈：
java虚拟机栈可以看作一个java方法执行的内存模型。在java方法执行的时候同时也会创建一个栈帧（Stack Frame），用来存储这个java方法里面的局部变量、操作栈、动态链接、方法出口等信息。java方法在被调用直至调用执行完毕就对应着栈帧在java虚拟机栈中的进栈出栈的过程。
局部变量表存放了预编译期可知的各种基本数据类型(boolean、bye、char、short、int、float、long、double）、对象引用（refernece类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可以指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

3. 本地方法栈：
跟虚拟机栈很类似，我们都知道java虚拟机栈是为虚拟机执行java方法（也就是字节码）服务的。而本地方法栈是为虚拟机用到的Native方法服务的。

4. java堆（Heap）：
java堆是在虚拟机启动的时候便会创建一大块内存，这块内存的主要目的是存放对象实例。所以这块内存是被所有线程所共享的。这一点在java虚拟机规范中的描述是：所有的对象实例和数组都要在堆上分配，但是随着JIT 编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换会让所描述的所有对象实例都在堆上分配变得不那么绝对了；
同时java堆也是垃圾收集器管理的主要区域，也称GC堆，毕竟存储的都是对象的实例；
java堆是可扩展的（-Xmx、-Xms控制），如果不够用是会产生OutOfMemoryError异常。

5. 方法区：
用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。和堆一样，都是多线程共享的。貌似方法区跟堆有着很多的相似之处，但是在方法区里面，垃圾收集行为在这里是比较少出现的，回收主要目标是对常量池和类型的卸载。所以回收效果非常不尽人满意，特别是对类型的卸载。
运行时常量池是用来存放编译期生成的各种字面量和符号的引用，这个过程在类加载后。
String.intern() 就可以把运行期间的常量放入运行时常量池。
具体描述是：当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。

在除了java堆外，虚拟机还可以另外开辟内存，可以使用native函数进行分配堆外内存，其中原理是在堆内有个DirectByBuffer对象作为着堆外内存的引用操作，实现两种内存“类似统一”的感觉，避免在java堆和Native堆来回数据复制。当然也要考虑堆外内存会受到物理和操作系统环境的限制，在设置java堆内存的时候需要注意。

每个线程都有自己的虚拟机栈，本地方法栈，程序计数器。所有线程共享着同一个方法区和堆。所以通常一个线程可以看到另一个线程对静态变量赋值，以及所有对象实例。

举个对象访问的例子：Object object = new Object();
Object object，如果是在方法体中，这句反映到虚拟机栈的本地变量表，作为一个reference类型数据出现。
new Object，这句会反映到java堆中，形成一个类型为Object的所有实例数据值的结构化内存。根据具体类型和虚拟机实现对象的内存布局的不同，所以这块内存的长度是不固定的。
同时java堆中还会保存能找到此对象的类型数据（即数据类型，类，父类，实现的接口，等）存到方法区。
访问对象，reference对象在所有不同虚拟机中访问方式大致分2种，分别是使用句柄和直接指针。通常我们的java栈里面的本地变量表里面的reference引用对象要向堆和方法区分别找到这个对象的实例数据和类型数据。
使用句柄时堆上会分出一块空间作为句柄池用来存储对象的实例数据地址和类型数据地址，然而栈的变量表存储的则是句柄的地址。我们会发现有句柄这个中介时，当实例数据地址变化的时候，只有句柄里面存储地址发生变化，避免带来跨界修改指针。
使用直接指针，栈中变量表存储的就是堆中对象的实例数据的地址，同时堆中对象实例数据里面也存有该对象的类型数据，可以看出直接指针方式会省掉一个指针定位，好处自然就是效率高了。
虚拟机sun HotSpot则是用第二种方式访问。

2. 垃圾回收器与内存分配策略
通常我们学习都是带着问题去学习的，经过半世纪的发展，内存的动态分配与内存回收技术已经相当成熟，一切都似进入自动化时代，那我们为什么还需要去深入了解GC和内存分配呢？很明显，如果我们的应用程序出现内存溢出或内存泄漏的时候，或者垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些自动化的技术实施必要的监控和调节。

判断对象存货算法：
根搜索算法（GC Roots Tracing）
在主流的商用程序语言中（java和C#，也包括老早的Lisp），都是用根搜索算法判断对象存活。

引用强度级别：
四种引用强度依次减弱
强引用（Strong Reference），
软引用（Soft Reference），
弱引用（Weak Reference），
虚引用（Phantom Reference），

垃圾搜集算法：
标记清除算法，
复制算法，
标记-整理算法，
分代收集算法，
---
layout: post
title:  "JVM垃圾收集器与内存分配"
date:   2014-07-18 15:49:00
categories: jvm
---
##垃圾收集算法

垃圾收集器通常有如下集中垃圾收集算法： 

1. 标记-清除算法 
2. 复制算法 
3. 标记-整理算法 
4. 分代收集算法 

###标记-清除算法

这是最基本的垃圾收集算法，其中包含两个步骤，首先标记需要回收的对象，再统一清除所有被标记的对象。后3种都基于这种算法，这种算法又2个缺点，一个是标记和清除的效率都不高，其二是清除后造成空间不连续。

###复制算法

这种算法是把内存按容量均分为2块 ， 首先用其中一块， 等空间用完后把需要保留的对象都复制到另一块内存上去再把这块内存里面所有数据都清空。然而每次回收的都是整块内存，所以内存分配时不用考虑内存碎片等复杂情况，只需要移动堆指针按顺序分配内存即可。这种算法的代价是需要分隔出一半内存，代价有点高。

现在商业的虚拟机都采用这种收集方式来回收新生代，IBM统计分析，在新生代中98%都是很快就挂掉的，所以内存不需要按照1：1均分，而是将内存分为一块较大的Eden和两块较小的Survivor的空间。使用过程中是使用Eden和其中一块Survivor，当内存回收时将需保留的都复制到另一块Survivor上，再将Eden和使用的Survivor全部清空。

还有一种情况，如果另一块Survivor没有足够的空间存放上次新生代收集下来的存活对象，这些对象会通过分配担保机制进入老年代。当然如果100%存活必然使用这种方法。但是面对老年代就不能直接性选用这种方法。

###标记整理算法

根据老年代的特点，于是有人推出这种算法。其原理是将存活对象和需要回收对象进行移动整理，在端边界进行以外的内存回收。这种方法是基于复制算法的多复制等不高效等缺点推出的。

###分代收集算法（Generational Collection）

当前商业虚拟机的垃圾收集都采用“分代收集算法”。这种算法是一种非常灵活的总结，它通过对对象的存活周期的不通将内存划分几块，把java堆分为新生代和老年代，然后通过不通年代的对象进行选择不同的收集算法。比如新生代大部分挂掉少量存活就用复制算法，牺牲少量的存活对象的复制；老年代存活率高，没有额外的担保空间就用“标记整理算法”或“标记清除算法”。

##垃圾收集器

垃圾收集器主要分为以下几种：

1. Serial收集器
2. ParNew收集器
3. Parallel Scavenge收集器
4. Serial Old收集器
5. Parallel Old收集器
6. CMS 收集器
7. G1 收集器

###Serial收集器

单线程垃圾收集器，每次收集程序就会停顿

###ParNew收集器

###多线程的Serial收集器

###Parallel Scavenge收集器

新生代收集器，使用的复制算法，同时也是并行多线程的收集器。相比CMS收集器此收集器的目标是达到一个可控制的吞吐量（Throughput），吞吐量的概念是CPU用于运行用户代码的时间和CPU总消耗的事件的比值，计算公式是：
吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）
例如：虚拟机总共运行100分钟 ， 垃圾收集花1分钟 ， 那么吞吐量就是99%

Parallel Scavenge收集器有两个参数来控制吞吐量：

‘’‘
-XX:MaxGCPauseMillis (最大垃圾收集停顿时间，大于0的毫秒数)
-XX:GCTimeRatio (吞吐量大小，大于0小于100的整数)
’‘’

设置最大垃圾收集停顿时间后，系统自己会调节收集时间停顿时间不超过此数值，但是缩短GC停顿时间缩短是以牺牲吞吐量和新生代空间为代价的。
例如，原来500M的新生代 10秒收集一次，停顿100毫秒
现在300M的新生代 5秒收集一次， 停顿70秒
所以设置最大垃圾收集停顿时间，系统GC调节会降低吞吐量的。

吞吐量大小设置，相当于垃圾收集时间占总时间的比率，也相当于吞吐量的倒数。
设置19 ， 即允许最大GC时间就占总时间1 / (1+19) = 5%
默认设置99 ， 即1 / (99+1) = 1%

由于与吞吐量密切相关，也称吞吐量优先收集器。

-XX:+UseAdaptiveSizePolicy （这个参数是开关参数，打开后就不用设置以下参数了）

-XX （新生代大小）
-XX:SurvivorRatio （Eden与Survivoe区比例）
-XX:PretenureSizeThreshold （晋级老年化对象年龄）

###Serial Old收集器

老年代版本的Serial收集器，使用的是“标记 – 整理算法” 。

###Parallel Old收集器

老年代版本的Parallel Scavenge收集器， 使用的是“标记 – 整理算法”。

###CMS 收集器

它是以获取最短回收停顿为目标的收集器， 这类收集器尤其重视服务器的响应速度，以给用户带来较好的体验，它使用的是“标记 – 清除算法”

运行过程分为以下4个步骤
初始标记（CMS initial mark） ：
关联GC Roots 能直接连接的对象
并发标记（CMS concurrent mark） ：
GC Roots Tracing
重新标记（CMS remark） ：
修正并发标记期间，因用户程序的继续运行而变动的对象的标记。这部分停顿长。
并发清除（CMS concurrent sweep）：
清除时间长

![Alt text](http://7u2srn.com1.z0.glb.clouddn.com/@/images/post/jvm01_01.png)

优点：并发收集、低停顿
缺点：
对cpu资源敏感， 即清理会让程序变慢，iCMS增量式并发收集器解决了这个问题，不过目前版本不再推荐使用。
无法处理浮动垃圾，这部分可以google。
当然基于标记清理的收集算法，内存不连续性也是一个缺点。

###G1 收集器

G1收集器是当前收集器技术发展的最前沿成果，在jdk 1.6_update14中提供了Early Access版本的G1收集器以供试用。不知道jdk1.7有不。这个需要查下。

优点：标记整理算法，不存在内存垃圾，对于长时间运行非常重要。
可以准确的控制停顿
解决了Parallel Scavenge收集器牺牲吞吐量的低停顿对象回收，因为它极力避免了全区域的垃圾收集，而不是整个新生代或老年代。
G1将java堆（包括新生代、老年代）划分为多个大小固定的独立区域，并跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，然后每次根据允许的收集时间，优先回收垃圾最多的区域。
就是因为存在区域的划分和优先级的回收，所以保证G1收集器在有限的时间获得最高的收集效率。